# Стратегия внедрения Graph Neural Networks (GNN) для прогнозирования дебита

На основе детального анализа предоставленных научных статей (STA-MGCN, SGP-GCN, PI-GNN) и текущей архитектуры проекта, разработан следующий план внедрения графовых нейронных сетей (GNN) для прогнозирования дебита жидкости.

## 1. Анализ ключевых идей из литературы (SOTA)

Проведенный анализ статей из папки `files_md` выявил три критически важных компонента для успешной модели:

1.  **STA-MGCN (Spatiotemporal Attention-Enhanced Multi-Graph CN):**
    *   **Суть:** Использование *нескольких графов* одновременно для описания разных типов связей.
    *   **Типы графов:**
        *   *Геометрический:* Физическое расстояние (у нас есть `coords.txt`, `well_distances.xlsx`).
        *   *Взаимодействия:* Связь нагнетательная-добывающая (у нас есть данные по инжекции).
        *   *Потоковый (Conductance):* Проницаемость/расстояние (можно аппроксимировать).
        *   *Динамическое подобие:* Схожесть кривых добычи (DTW или корреляция).
    *   **Вывод:** Нельзя полагаться только на расстояние. Нужно строить мульти-граф.

2.  **SGP-GCN (Spatial-Geological Perception GCN):**
    *   **Суть:** Объединение пространственной и *геологической* информации. Использование механизма Attention для взвешивания важности соседей.
    *   **Кластеризация:** Предлагается алгоритм SPC (Sparsification based on Production Clustering) для удаления "шумных" связей между скважинами с принципиально разным поведением.
    *   **Вывод:** Использовать GAT (Graph Attention Network) вместо обычного GCN, чтобы модель сама учила вес связи, игнорируя нерелевантных соседей.

3.  **PI-GNN (Physics-Informed GNN):**
    *   **Суть:** Внедрение физики (уравнения материального баланса или CRM) прямо в функцию потерь или структуру графа.
    *   **Вывод:** Мы уже используем `AdaptivePhysicsLoss`. Его нужно расширить на графовый уровень (например, штраф за нарушение гладкости сигнала между соседними скважинами - Laplacian Regularization).

---

## 2. Предлагаемая Архитектура

Мы будем использовать библиотеку **PyTorch Geometric (PyG)** как стандарт индустрии, что обеспечит надежность, скорость и простоту поддержки (в отличие от самописных слоев).

### Вариант 1: ST-GNN (Spatiotemporal GNN) — Самостоятельная модель
Это наиболее мощный вариант, полностью заменяющий или работающий в ансамбле с текущим TSMixerx.

*   **Входные данные:**
    *   Узлы (Nodes): Временные ряды $X_t$ (дебит, давление, обводненность) + Статические эмбеддинги (координаты).
    *   Ребра (Edges): Мульти-граф (расстояние + корреляция + инжекция).
*   **Архитектура:**
    1.  **Multi-Graph Encoder:** Параллельные слои `GATv2Conv` (Graph Attention v2) для каждого типа графа. Это позволит модели "слушать" геометрических соседей отдельно от корреляционных.
    2.  **Fusion Layer:** Объединение выходов с разных графов (взвешенная сумма или конкатенация).
    3.  **Temporal Block:** LSTM или GRU с механизмом *Temporal Attention* (как в STA-MGCN) для обработки временной динамики обновленных узловых фичей.
    4.  **Decoder:** Полносвязный слой (MLP) для генерации прогноза на 6 месяцев ($H \to \hat{Y}$).
*   **Преимущества:** Явное моделирование влияния соседей и инжекции. Способность учить сложные пространственно-временные паттерны.

### Вариант 2: Chronos-2 + GNN Residuals — Гибридная схема
Использование GNN как "корректировщика" для мощной Zero-shot модели Chronos-2.

*   **Логика:**
    1.  Chronos-2 делает базовый прогноз $\hat{Y}_{base}$ для каждой скважины *независимо* (univariate), отлично улавливая тренды.
    2.  GNN получает на вход: Историю $X$, Базовый прогноз $\hat{Y}_{base}$ и Граф соседей.
    3.  GNN предсказывает *остаточную ошибку* (residual) $\delta$, вызванную влиянием соседей (интерференция), которую Chronos не видит.
    4.  Итоговый прогноз: $\hat{Y}_{final} = \hat{Y}_{base} + \delta$.
*   **Преимущества:** Сочетает мощь LLM для временных рядов (Chronos) и локальное знание физики/соседей (GNN). Меньше рисков "сломать" прогноз, если GNN не обучится.

---

## 3. План реализации

### Этап 1: Подготовка данных и Графов (`src/graph_data.py`)
Необходимо создать модуль для генерации графов из текущих данных.

1.  **Geo Graph:** Строим граф k-ближайших соседей (KNN) или по радиусу на основе `coords.txt`.
2.  **Interaction Graph:** Строим направленный граф `Injector -> Producer` на основе корреляции `wwir` (закачка) и `wlpr` (добыча) с учетом лага.
3.  **Data Loader:** Реализовать кастомный `PyGDataset`, который возвращает не просто тензоры, а объекты `Batch` из PyTorch Geometric, содержащие `x` (фичи), `edge_index` (связи) и `edge_attr` (веса).

### Этап 2: Реализация Моделей (`src/models_gnn.py`)
Реализация класса `GraphTSMixer` (условное название для ST-GNN).

*   Использовать `torch_geometric.nn.GATv2Conv` для сверток.
*   Реализовать `TemporalAttentionLayer` (по мотивам STA-MGCN) для взвешивания важности временных шагов.
*   Обеспечить совместимость интерфейса с `NeuralForecast` (методы `forward`, `training_step`), чтобы встроиться в существующий пайплайн.

### Этап 3: Интеграция и Обучение (`src/wlpr_pipeline.py`)
1.  **Конфигурация:** Добавить в `PipelineConfig` параметры:
    *   `gnn_hidden_dim`, `gnn_heads`, `graph_types` (список используемых графов).
2.  **Loss Function:** Модифицировать `PhysicsInformedLoss`. Добавить компонент `GraphLaplacianLoss`:
    $$L_{smooth} = \sum_{i,j} A_{ij} || \hat{y}_i - \hat{y}_j ||^2$$
    Это заставит модель делать похожие прогнозы для сильно связанных скважин (физическая согласованность).

## 4. Необходимые библиотеки

Для реализации плана потребуется установить стандартный стек для GNN на PyTorch:

```txt
torch-geometric>=2.4.0
torch-scatter
torch-sparse
torch-cluster
```

## 5. Рекомендация к действию

Рекомендуется начать с **Варианта 1 (ST-GNN)** как основного, так как он дает наибольший контроль над архитектурой и позволяет явно моделировать физику взаимодействий. Вариант 2 можно реализовать как эксперимент, если качество Варианта 1 будет недостаточным.

1.  **Установить зависимости.**
2.  **Создать `src/graph_data.py`** и проверить построение графов.
3.  **Реализовать `src/models_gnn.py`** с базовой архитектурой GAT+LSTM.
4.  **Запустить обучение** на малом наборе данных для проверки сходимости.
